#include "driver/gpio.h"
#include <esp_system.h>
#include <esp_event.h>
#include <nvs_flash.h>
#include <esp_log.h>
#include <esp_event_base.h>
#include "gpio.h"
#include "common.h"
#include "driver/i2c.h"
#include "driver/ledc.h"
#include "driver/pcnt.h"
#include "led_sequence.h"
#include "common/ps5_data.h"
#include "common/i2c.h"
#include "common/deepsleep.h"
#include "hw_def.h"
#include "wifi.h"
#include "led.h"
#include "buzzer.h"
#include <memory.h>
#include "servo.h"
#include "arm.h"

ESP_EVENT_DEFINE_BASE(GPIO_EVENT);
#define I2C_SLAVE_NUM 0
#define I2C_SLAVE_TX_BUF_LEN (16 * sizeof(ps5_t))
#define I2C_SLAVE_RX_BUF_LEN (4 * sizeof(ps5_t))

#define PCNT_UNIT_MOTOR1 PCNT_UNIT_0
#define PCNT_UNIT_MOTOR2 PCNT_UNIT_1
#define PCNT_UNIT_MOTOR3 PCNT_UNIT_2
#define PCNT_UNIT_MOTOR4 PCNT_UNIT_3
#define STATE_BIT_REVERSE 0
#define STATE_BIT_FWD 1
#define STATE_BIT_HORN 2
#define STATE_BIT_LED 3
#define STATE_CONTROLLER_CONNECTED 4
#define STATE_BIT_R3 5
#define STATE_BIT_CROSS 6

typedef struct
{
	int unit;
	int motor_revolutions;
	int motor_direction;
} motor_pcnt;

static motor_pcnt motor1_pcnt = {PCNT_UNIT_MOTOR1, 0, 0};
static motor_pcnt motor2_pcnt = {PCNT_UNIT_MOTOR2, 0, 0};
static motor_pcnt motor3_pcnt = {PCNT_UNIT_MOTOR3, 0, 0};
static motor_pcnt motor4_pcnt = {PCNT_UNIT_MOTOR4, 0, 0};

// This is a logarithmic curve generated by motorlogcurve.py
static uint16_t throttle_map_high[] = {0, 1019, 1614, 2037, 2365, 2633, 2860, 3056, 3229, 3384, 3524, 3652, 3769, 3878, 3979, 4074, 4163, 4247, 4327, 4402, 4474, 4542, 4608, 4670, 4730, 4788, 4843, 4897, 4948, 4998, 5046, 5093, 5138, 5182, 5225, 5266, 5306, 5345, 5384, 5421, 5457, 5493, 5527, 5561, 5594, 5626, 5658, 5689, 5719, 5749, 5778, 5806, 5834, 5862, 5889, 5915, 5941, 5967, 5992, 6017, 6041, 6065, 6088, 6111, 6134, 6157, 6179, 6201, 6222, 6243, 6264, 6285, 6305, 6325, 6345, 6364, 6383, 6402, 6421, 6439, 6458, 6476, 6493, 6511, 6528, 6546, 6563, 6579, 6596, 6612, 6629, 6645, 6661, 6676, 6692, 6707, 6723, 6738, 6753, 6767, 6782, 6796, 6811, 6825, 6839, 6853, 6867, 6880, 6894, 6907, 6921, 6934, 6947, 6960, 6973, 6985, 6998, 7011, 7023, 7035, 7047, 7060, 7072, 7083, 7095, 7107, 7119, 7130, 7142, 7153, 7164, 7175, 7186, 7197, 7208, 7219, 7230, 7241, 7251, 7262, 7272, 7283, 7293, 7303, 7313, 7323, 7333, 7343, 7353, 7363, 7373, 7383, 7392, 7402, 7411, 7421, 7430, 7439, 7449, 7458, 7467, 7476, 7485, 7494, 7503, 7512, 7521, 7530, 7538, 7547, 7556, 7564, 7573, 7581, 7590, 7598, 7606, 7615, 7623, 7631, 7639, 7647, 7655, 7663, 7671, 7679, 7687, 7695, 7703, 7711, 7718, 7726, 7734, 7741, 7749, 7756, 7764, 7771, 7779, 7786, 7793, 7801, 7808, 7815, 7822, 7829, 7836, 7844, 7851, 7858, 7865, 7872, 7878, 7885, 7892, 7899, 7906, 7913, 7919, 7926, 7933, 7939, 7946, 7952, 7959, 7965, 7972, 7978, 7985, 7991, 7998, 8004, 8010, 8017, 8023, 8029, 8035, 8042, 8048, 8054, 8060, 8066, 8072, 8078, 8084, 8090, 8096, 8102, 8108, 8114, 8120, 8126, 8131, 8137, 8143, 8191};
static uint16_t throttle_map_low[] = {0, 501, 793, 1001, 1162, 1294, 1405, 1502, 1587, 1663, 1732, 1794, 1852, 1906, 1956, 2002, 2046, 2087, 2126, 2163, 2199, 2232, 2264, 2295, 2324, 2353, 2380, 2406, 2432, 2456, 2480, 2503, 2525, 2546, 2567, 2588, 2608, 2627, 2646, 2664, 2682, 2699, 2716, 2733, 2749, 2765, 2780, 2795, 2810, 2825, 2839, 2853, 2867, 2881, 2894, 2907, 2920, 2932, 2944, 2957, 2969, 2980, 2992, 3003, 3014, 3025, 3036, 3047, 3058, 3068, 3078, 3088, 3098, 3108, 3118, 3127, 3137, 3146, 3155, 3164, 3173, 3182, 3191, 3200, 3208, 3217, 3225, 3233, 3241, 3249, 3257, 3265, 3273, 3281, 3288, 3296, 3304, 3311, 3318, 3326, 3333, 3340, 3347, 3354, 3361, 3368, 3374, 3381, 3388, 3394, 3401, 3407, 3414, 3420, 3426, 3433, 3439, 3445, 3451, 3457, 3463, 3469, 3475, 3481, 3487, 3492, 3498, 3504, 3509, 3515, 3521, 3526, 3531, 3537, 3542, 3548, 3553, 3558, 3563, 3568, 3574, 3579, 3584, 3589, 3594, 3599, 3604, 3609, 3613, 3618, 3623, 3628, 3633, 3637, 3642, 3647, 3651, 3656, 3660, 3665, 3669, 3674, 3678, 3683, 3687, 3692, 3696, 3700, 3704, 3709, 3713, 3717, 3721, 3725, 3730, 3734, 3738, 3742, 3746, 3750, 3754, 3758, 3762, 3766, 3770, 3774, 3778, 3781, 3785, 3789, 3793, 3797, 3800, 3804, 3808, 3811, 3815, 3819, 3822, 3826, 3830, 3833, 3837, 3840, 3844, 3847, 3851, 3854, 3858, 3861, 3865, 3868, 3872, 3875, 3878, 3882, 3885, 3888, 3892, 3895, 3898, 3901, 3905, 3908, 3911, 3914, 3917, 3921, 3924, 3927, 3930, 3933, 3936, 3939, 3943, 3946, 3949, 3952, 3955, 3958, 3961, 3964, 3967, 3970, 3973, 3976, 3978, 3981, 3984, 3987, 3990, 3993, 3996, 3999, 4001, 4095};
static uint16_t *throttle_map;
static TaskHandle_t ps5_task;
static TaskHandle_t rpm_task;

metrics_t metrics = {0};

static const char *TAG = "gpio_c";
static bool arm_activated = false;

static mcpwm_cmpr_handle_t comparator_steering;

#define LED_SET_DISCONNECTED_PATTERN() \
	led_pattern p = {0};               \
	p[0].r = 255;                      \
	led_set_rotating_pattern(&p, 200)

#define LED_SET_IDLE_PATTERN() led_set_rotating_pattern(&led_pattern_rainbow, 100)
#define LED_SET_REVERSE_PATTERN() led_set_flashing_pattern(&led_pattern_red, 100, 100)
#define LED_SET_ATTENTION_PATTERN()        \
	led_pattern p;                         \
	memset(&p, 255, sizeof(led_pattern));  \
	led_set_flashing_pattern(&p, 100, 50); \
	led_set_flashing_pattern(&led_pattern_red, 100, 100)

#define LED_SET_ATTENTION_PATTERN()       \
	led_pattern p;                        \
	memset(&p, 255, sizeof(led_pattern)); \
	led_set_flashing_pattern(&p, 100, 50)

#define LED_SET_GOING_TO_SLEEP_PATTERN() \
	led_pattern p = {0};                 \
	p[0].b = 255;                        \
	p[7].b = 255;                        \
	p[13].b = 255;                       \
	p[21].b = 255;                       \
	led_set_rotating_pattern(&p, 1000)

#define LED_SET_ARM_PATTERN() \
	led_pattern p = {0};      \
	p[0].b = 255;             \
	p[7].b = 255;             \
	p[13].b = 255;            \
	p[21].b = 255;            \
	p[0].g = 255;             \
	p[7].g = 255;             \
	p[13].g = 255;            \
	p[21].g = 255;            \
	led_set_rotating_pattern(&p, 200)

void process_steering(int8_t axis)
{
	// we want an angle between -31 to 32 and we have a number from -127 to 128
	int angle = axis >> 2;
	metrics.steering_angle = angle;
	servo_set_angle(&comparator_steering, angle);
}

void process_throttle(uint8_t t, int8_t direction)
{

	// PS5 controller returns an 8bit value that needs to be mapped to 13bit for the PWM unit
	// I map this using a logarithmic curve rather than simply a linear map because at low values, the motor doesn't turn at all.
	uint16_t throttle = throttle_map[t];

	if (direction == 1)
	{
		metrics.direction = 1;
		metrics.throttle = t;
		metrics.pwm = throttle;
	}
	else
	{
		metrics.direction = -1;
		metrics.throttle = t;
		metrics.pwm = throttle;
	}

	// TODO
	// DC motor will briefly use 2 times the amount of stall current if it goes from one direction to the other.
	// so we need to carefully ramp this down instead. I think LEDC has a transitioning mechanism that could be used for that
	// ledc_set_fade_with_time(), ledc_set_fade_with_step(), ledc_set_fade()

	ESP_LOGI(TAG, "Throttle=%i (%i)", throttle, t);
	if (direction == 1)
	{
		ESP_ERROR_CHECK(ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 0));
		ESP_ERROR_CHECK(ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0));
		ESP_ERROR_CHECK(ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1, throttle));
		ESP_ERROR_CHECK(ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1));
	}
	else
	{
		ESP_ERROR_CHECK(ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1, 0));
		ESP_ERROR_CHECK(ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_1));
		ESP_ERROR_CHECK(ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, throttle));
		ESP_ERROR_CHECK(ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0));
	}
}

void report_metrics()
{
	broadcast_metric(&metrics);
}

void check_rpm(void *arg)
{
	// unsigned long last_rpm_check = (esp_timer_get_time() / 1000ULL);
	while (1)
	{
		//  Check counter every second
		vTaskDelay(1000 / portTICK_PERIOD_MS);

		uint16_t rpm1 = (motor1_pcnt.motor_revolutions * 60) >> 3; // divide by 8 because the PCNT is set the trigger events 8 times faster
		uint16_t rpm2 = (motor2_pcnt.motor_revolutions * 60) >> 3; // divide by 8 because the PCNT is set the trigger events 8 times faster
		uint16_t rpm3 = (motor3_pcnt.motor_revolutions * 60) >> 3; // divide by 8 because the PCNT is set the trigger events 8 times faster
		uint16_t rpm4 = (motor4_pcnt.motor_revolutions * 60) >> 3; // divide by 8 because the PCNT is set the trigger events 8 times faster

		// TODO: For some reason, the RPM reported is twice as higher than the rated value of my motor. Why? We'll just divide by 2 for the moment
		metrics.rpm1 = rpm1 >> 1;
		metrics.rpm2 = rpm2 >> 1;
		metrics.rpm3 = rpm3 >> 1;
		metrics.rpm4 = rpm4 >> 1;

		portDISABLE_INTERRUPTS();
		motor1_pcnt.motor_revolutions = 0;
		motor2_pcnt.motor_revolutions = 0;
		motor3_pcnt.motor_revolutions = 0;
		motor4_pcnt.motor_revolutions = 0;
		portENABLE_INTERRUPTS();

		uint16_t mm_per_minutes = ((metrics.rpm1 + metrics.rpm2 + metrics.rpm3 + metrics.rpm4) / 4) * WHEEL_SIZE_MM;
		metrics.speed = mm_per_minutes / 1667; // should be 16670 but we will do fixed point maths to keep the decimal without using the FPU
		report_metrics();
	}
}

static bool was(uint32_t old_state, uint32_t new_state, uint32_t bit)
{
	return ((old_state & (1 << bit)) && !(new_state & (1 << bit)));
}

static bool is_now(uint32_t old_state, uint32_t new_state, uint32_t bit)
{
	return (!(old_state & (1 << bit)) && (new_state & (1 << bit)));
}

static bool is(uint32_t new_state, uint32_t bit)
{
	return (new_state & (1 << bit));
}

void update_led(uint32_t old_state, uint32_t new_state)
{
	if (!is(new_state, STATE_CONTROLLER_CONNECTED))
	{
		LED_SET_DISCONNECTED_PATTERN();
		return;
	}

	if (is_now(old_state, new_state, STATE_BIT_CROSS) && arm_activated)
	{
		LED_SET_ARM_PATTERN();
		return;
	}
	else if (is_now(old_state, new_state, STATE_BIT_CROSS) && !arm_activated)
	{
		LED_SET_IDLE_PATTERN();
		return;
	}
	else if (arm_activated)
	{
		return;
	}

	if (is_now(old_state, new_state, STATE_CONTROLLER_CONNECTED))
	{
		LED_SET_IDLE_PATTERN();
		return;
	}

	if (is(new_state, STATE_BIT_LED))
	{
		if (is_now(old_state, new_state, STATE_BIT_LED))
		{
			// only do this after the transition
			LED_SET_ATTENTION_PATTERN();
		}
		// If LED button pressed, don't try to change anything anymore
		return;
	}

	if (was(old_state, new_state, STATE_BIT_LED))
	{
		if (is(new_state, STATE_BIT_REVERSE))
		{
			LED_SET_REVERSE_PATTERN();
			return;
		}
		LED_SET_IDLE_PATTERN();
		return;
	}

	if (is_now(old_state, new_state, STATE_BIT_REVERSE))
	{
		LED_SET_REVERSE_PATTERN();
		return;
	}

	if (was(old_state, new_state, STATE_BIT_REVERSE))
	{
		LED_SET_IDLE_PATTERN();
		return;
	}
}

void update_buzzer(uint32_t old_state, uint32_t new_state)
{
	if (!is(new_state, STATE_CONTROLLER_CONNECTED))
	{
		ESP_LOGI(TAG, "Buzzer: ctrl not connected");
		metrics.horn = 0;
		buzzer_set_off();
		return;
	}

	if (is_now(old_state, new_state, STATE_BIT_CROSS) && arm_activated)
	{
		buzzer_set_off();
		return;
	}
	else if (arm_activated)
	{
		return;
	}

	if (is(new_state, STATE_BIT_HORN))
	{
		if (is_now(old_state, new_state, STATE_BIT_HORN))
		{
			// only do this after the transition
			metrics.horn = 1;
			buzzer_set_intermitent(100, 100); // Anything below 100 should probably use the hardware PWM instead
		}
		// If LED button pressed, don't try to change anything anymore
		return;
	}
	metrics.horn = 0;

	if (was(old_state, new_state, STATE_BIT_HORN))
	{
		if (is(new_state, STATE_BIT_REVERSE))
		{
			buzzer_set_intermitent(1000, 500);
			return;
		}
		buzzer_set_off();
		return;
	}

	if (is_now(old_state, new_state, STATE_BIT_REVERSE))
	{
		buzzer_set_intermitent(1000, 500);
		return;
	}

	if (was(old_state, new_state, STATE_BIT_REVERSE))
	{
		buzzer_set_off();
		return;
	}
}

// Dumb state machine
void process_state(ps5_t *data)
{
	static uint32_t current_state = 0;

	bool pressing_cross = (data->button.cross != 0);
	bool controller_connected = data->controller_connected;
	bool pressing_led = (data->button.triangle != 0);
	bool pressing_r3 = (data->button.r3 != 0);
	bool pressing_horn = (data->button.circle != 0);

	bool reverse = 0;
	bool fwd = 0;

	// We don't support braking for now (setting both directions high)
	// We should though. But setting both pins to 1 instead of PWM
	if (data->analog.button.r2)
	{
		fwd = 1;
	}
	else if (data->analog.button.l2)
	{
		reverse = 1;
	}

	uint32_t new_state = (pressing_horn << STATE_BIT_HORN) |
						 (pressing_r3 << STATE_BIT_R3) |
						 (pressing_cross << STATE_BIT_CROSS) |
						 (reverse << STATE_BIT_REVERSE) |
						 (fwd << STATE_BIT_FWD) |
						 (controller_connected << STATE_CONTROLLER_CONNECTED) |
						 (pressing_led << STATE_BIT_LED);

	ESP_LOGI(TAG, "Current state: %lu, new state: %lu", current_state, new_state);
	metrics.controller_battery = data->status.battery;

	if (is_now(current_state, new_state, STATE_BIT_CROSS))
	{
		arm_activated = !arm_activated;
		arm_enable(arm_activated);
	}

	// TODO: pressing L2 or R2 while in arm mode will change the LED and Buzzer. It should not Should make a better FSM
	if (arm_activated)
	{
		process_throttle(0, 0);
		arm_move(data->analog.stick.lx, data->analog.stick.ly, data->analog.stick.rx, data->analog.stick.ry);
	}
	else
	{
		process_throttle(fwd ? data->analog.button.r2 : data->analog.button.l2, fwd);
		process_steering(data->analog.stick.rx);
	}

	if (current_state == new_state)
	{
		return;
	}

	update_led(current_state, new_state);
	update_buzzer(current_state, new_state);

	if (is_now(current_state, new_state, STATE_BIT_R3))
	{
		if (throttle_map == throttle_map_high)
		{
			throttle_map = throttle_map_low;
		}
		else
		{

			throttle_map = throttle_map_high;
		}
	}

	current_state = new_state;
}

void poll_ps5(void *arg)
{
	uint8_t i2c_byte;
	uint8_t addr = (ESP_SLAVE_ADDR << 1);
	ps5_t data;
	uint8_t opcode = 1;

	while (1)
	{
		esp_err_t err;

		ps5_t data;
		size_t s = sizeof(data);
		size_t size = i2c_slave_read_buffer(I2C_SLAVE_NUM, &data, sizeof(ps5_t), 1000 / portTICK_PERIOD_MS);
		if (size == s)
		{

			uint8_t received_checksum = data.checksum;
			data.checksum = 0;
			uint8_t c = 0;
			for (int i = 0; i < sizeof(ps5_t) - 1; i++)
			{
				c += ((uint8_t *)&data)[i];
			}
			if (received_checksum != c)
			{
				ESP_LOGI(TAG, ">>>>>>>>>>>>>>>>>> I2C BAD CHECKSUM. RESETTING CONTROL %i/%i<<<<<<<<<<<<<<<<<<<<<", received_checksum, c);
				memset(&data, 0, sizeof(ps5_t));
				data.latestPacket = 1;
				data.controller_connected = 1;
			}

			if (!data.controller_connected)
			{
				memset(&data, 0, sizeof(ps5_t));
				data.latestPacket = 1;
			}

			uint8_t *d = &data;
			ESP_LOGI(TAG, "===========%i, %i, %i, %i, %i", (int8_t)d[0], (int8_t)d[1], (int8_t)d[2], (int8_t)d[3], d[sizeof(ps5_t) - 1]);
			if (data.latestPacket)
			{
				ESP_LOGI(TAG, "New PS5 Packet. Throttle=%i", data.analog.button.r2);
				// ESP_LOGI(TAG, "New PS5 Packet. l1=%i", data.button.l1);
				process_state(&data);
			}
		}
	}
}

void pwm_motor_init()
{

// Don't let the naming fool you. LEDC is not for LED control. It is the name of the peripheral
// in the ESP32 for controlling a LED but it is really just a PWM controller
#define LEDC_TIMER LEDC_TIMER_0
#define LEDC_MODE LEDC_LOW_SPEED_MODE
#define LEDC_DUTY_RES LEDC_TIMER_13_BIT // Set duty resolution to 13 bits
#define LEDC_FREQUENCY (4000)			// Frequency in Hertz. Set frequency at 4 kHz
	ledc_timer_config_t ledc_timer = {
		.speed_mode = LEDC_MODE,
		.duty_resolution = LEDC_DUTY_RES,
		.timer_num = LEDC_TIMER,
		.freq_hz = LEDC_FREQUENCY, // Set output frequency at 4 kHz
		.clk_cfg = LEDC_AUTO_CLK};
	ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));

	ledc_channel_config_t ledc_channel = {
		.speed_mode = LEDC_MODE,
		.channel = LEDC_CHANNEL_0,
		.timer_sel = LEDC_TIMER,
		.intr_type = LEDC_INTR_DISABLE,
		.gpio_num = GPIO_MOTOR_PWM1,
		.duty = 0,
		.hpoint = 0};
	ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel));

	ledc_channel_config_t ledc_channel2 = {
		.speed_mode = LEDC_MODE,
		.channel = LEDC_CHANNEL_1,
		.timer_sel = LEDC_TIMER,
		.intr_type = LEDC_INTR_DISABLE,
		.gpio_num = GPIO_MOTOR_PWM2,
		.duty = 0,
		.hpoint = 0};
	ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel2));
}

static void IRAM_ATTR pcnt_isr(void *arg)
{
	motor_pcnt *pcnt = (motor_pcnt *)arg;
	pcnt->motor_revolutions++;
	pcnt->motor_direction = 1;

	uint32_t status = 0;
	pcnt_get_event_status(pcnt->unit, &status);

	pcnt->motor_revolutions++;
	if (status & PCNT_EVT_H_LIM)
	{
		pcnt->motor_direction = 1;
	}
	else if (status & PCNT_EVT_L_LIM)
	{
		pcnt->motor_direction = -1;
	}
}

esp_err_t pcnt_motor_init(motor_pcnt *pcnt, uint8_t pinA, uint8_t pinB)
{
	esp_err_t ret;
	static bool isr_installed = false;

	const pcnt_config_t encodercfg = {
		.pulse_gpio_num = pinA,
		.ctrl_gpio_num = pinB,
		.lctrl_mode = PCNT_MODE_REVERSE,
		.hctrl_mode = PCNT_MODE_KEEP,
		.channel = PCNT_CHANNEL_0,
		.unit = pcnt->unit,
		.pos_mode = PCNT_COUNT_INC,
		.neg_mode = PCNT_COUNT_DIS,

		// The motor we're using, FIT0186 does 16 pulses per rev before gears. This equals to 700 pulses per gear shaft rev.
		// The number of pulses per rev that it generates is 700. We'll trigger every 88 so that we can have a finer grain of detection
		// Increasing the granularity gives us amore precise reading
		.counter_h_lim = 88,
		.counter_l_lim = -88,
	};

	pcnt_unit_config(&encodercfg);

	pcnt_set_filter_value(pcnt->unit, 100);
	pcnt_filter_enable(pcnt->unit);

	pcnt_event_enable(pcnt->unit, PCNT_EVT_H_LIM);
	pcnt_event_enable(pcnt->unit, PCNT_EVT_L_LIM);
	if (!isr_installed)
	{
		pcnt_isr_service_install(0);
		isr_installed = true;
	}
	pcnt_isr_handler_add(pcnt->unit, pcnt_isr, (void *)pcnt);

	pcnt_counter_pause(pcnt->unit);
	pcnt_counter_clear(pcnt->unit);
	pcnt_counter_resume(pcnt->unit);
	return ESP_OK;
}

void on_start_sleep()
{
	LED_SET_GOING_TO_SLEEP_PATTERN();
	vTaskDelay(2500 / portTICK_PERIOD_MS);
	led_turnoff();
	vTaskDelay(500 / portTICK_PERIOD_MS);
}

void dwn_gpio_init()
{
	throttle_map = &throttle_map_high;

	init_deep_sleep(GPIO_SLEEP_BUTTON, on_start_sleep);

	i2c_config_t conf_slave = {
		.sda_io_num = GPIO_SDA,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_io_num = GPIO_SCL,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.mode = I2C_MODE_SLAVE,
		.slave.addr_10bit_en = 0,
		.slave.slave_addr = ESP_SLAVE_ADDR,
		.clk_flags = 0,
	};

	ESP_ERROR_CHECK(i2c_param_config(I2C_SLAVE_NUM, &conf_slave));
	i2c_driver_install(I2C_SLAVE_NUM, conf_slave.mode, I2C_SLAVE_RX_BUF_LEN, I2C_SLAVE_TX_BUF_LEN, 0);

	buzzer_init();
	led_init();
	servo_init();
	servo_create(GPIO_STEERING, &comparator_steering);
	arm_init();
	pwm_motor_init();
	pcnt_motor_init(&motor1_pcnt, MOTOR1SENSOR1, MOTOR1SENSOR2);
	pcnt_motor_init(&motor2_pcnt, MOTOR2SENSOR1, MOTOR2SENSOR2);
	pcnt_motor_init(&motor3_pcnt, MOTOR3SENSOR1, MOTOR3SENSOR2);
	pcnt_motor_init(&motor4_pcnt, MOTOR4SENSOR1, MOTOR4SENSOR2);

	led_pattern p = {0};
	p[0].r = 255;
	led_set_rotating_pattern(&p, 200); // to show a "disconnected" mode

	servo_start();
	// Using a task scheduler would be more appropriate here to be able to set priorities
	xTaskCreate(check_rpm, "check_rpm", 4096, NULL, 5, &rpm_task);
	xTaskCreate(poll_ps5, "poll_ps5", 4096, NULL, 5, &ps5_task);
}

void gpio_suspend()
{
	vTaskSuspend(ps5_task);
	vTaskSuspend(rpm_task);
}